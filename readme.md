
#base64编码学习

	创建时间：2016.4.6 23:32

以字符串13为例，讨论一下base64编码过程。

###第一步：Ascii转16进制

首先把13拆成"1"和"3"的Ascii码。

查看Ascii码对照表可以看出"1"对应16进制31，"3"对应十六进制33。

按十六进制标准需要加上0x，于是得到以下结果。

```
1 -> 0x31
3 -> 0x33
```

`这里缺一张对照表`

###第二步：将16进制转成10进制

计算方式：（从右往左，数学的算法，个位,十位...）

```
0位 1 x 16^0 = 1 x 1 = 1
1位 3 x 16^1 = 3 x 16 = 48

得到 1 + 48 = 49

0位 3 x 16^0 = 3 x 1 = 3
1位 3 x 16^1 = 3 x 16 = 48

得到 3 + 48 = 51

以此类推

0xabc...n=a*16^(n-a)+b*16^(n-b)+...+n*16^0
````

最终得到结果：

```
0x31 -> 49
0x33 -> 51
```

###第三步：转成二进制

十进制转二进制的计算方式：

![十进制转二进制](resources/1.png =400x)

得到结果：

```
49 -> 00110001
51 -> 00110011
```

###第四步：补零和分组

将两组二进制组合起来，每六位分成一组，得到：

`001100 010011 0011`

因为最后一组只有四位，为了满足每组六位的规则，我们给它补两个0，得到：

`001100 010011 001100`

这一步的补零数要记得，现在补几个零，转成base64后就要在字符串最后加上几个等号。

###第五步：转十进制再转base64

接下来把每一组6位二进制转成对应的十进制数。

![base64索引表](resources/3.png =400)

最后拿base64对照表，把十进制转成对应的base64字符，得到的字符串在一起，最后加上补零数的等号。

这样就算完成了。

===

###另一种解决方法

>下面这段进阶在第五步之前，是了解到的另一种编码方式，但是后面没走通，还没解决。

如果是做base64转码，后面这几步都不用了。

因为每8位二进制占一字节，所以我们给每组前面加两个00，得到：

`00001100 00010011 00001100`

###第五步：二进制转16进制

将三组二进制分别转成对应16进制。

![二进制转16进制对照表](resources/2.jpg =400x)

参照二进制与16进制对照表，我们将每四位分一组，分别对应一个16进制编码，得到：

```
0000 1100 -> 0C
0001 0011 -> 13
0000 1100 -> 0C
```

###第六步：16进制转Ascii并拼接

将16进制码转为对应的Ascii码，拼接起来最终得到的就是base64编码。

```
0C -> FF
13 -> DC3
0C -> FF
```

这个过程主要对信息进行加工，变成不可读。

###相关资料

#####图片base64格式

格式 + 位图 + 二进制信息


#####0x开头表示16进制。

```
16进制即逢16进1，其中用A，B，C，D，E，F（字母不区分大小写）这六个字母来分别表示10，11，12，13，14，15。故而有16进制每一位上可以是从小到大为0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F共16个大小不同的数。

16进制到十进制

16进制数的第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方……
所以，在第N（N从0开始）位上，如果是是数 X （X 大于等于0，并且X小于等于 15，即：F）表示的大小为 X * 16的N次方。
例：2AF5换算成10进制:

用竖式计算：

第0位： 5 * 16^0 = 5
第1位： F * 16^1 = 240
第2位： A * 16^2= 2560
第3位： 2 * 16^3 = 8192

10997
直接计算就是：
5 * 16^0 + F * 16^1 + A * 16^2 + 2 * 16^3 = 10997
```

#####其他

window.atob()使用方法：https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa
